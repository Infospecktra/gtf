/* Generated by Together */

package org.yang.customized.gtf.services.dataAccess;

import java.util.HashMap;
import java.io.Serializable;
import java.io.InputStream;
import org.yang.util.xml.XmlRWUtil;
import java.util.ArrayList;
import java.util.Iterator;
import org.yang.util.SMUtility;
import org.yang.services.dataAccess.Data;
import org.yang.services.dataAccess.DataGroup;
import org.yang.services.dataAccess.DataUnavailableException;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
import org.apache.commons.lang.SerializationUtils;

public class ProjectFactory
{
    private static Object lock = new Object();

    private static HashMap projectTemplateMap = null;
    private static HashMap stageTemplateMap = null;
    private static HashMap timetableTemplateMap = null;
    private static HashMap scheduleTemplateMap = null;

    private static ProjectFactory me = null;

    private String defaultProject = null;

    private ProjectFactory() throws ProjectInitializationException
    {
       loadTemplate("ProjectFactory.xml", "TimeTable.xml");
    }

    public static ProjectFactory getFactory() throws ProjectInitializationException
    {
       if(null==me)
       {
          synchronized(lock)
          {
             if(null==me)
             {
                me = new ProjectFactory();
             }
          }
       }

       return me;
    }

    public Project createProject(String type) throws ProjectInitializationException, DataUnavailableException
    {
       Project project = getProjectTemplate(type);
       project.setFactory(this);
       return project;
    }

    public Timetable getTimetableTemplate(String pType)
    {
//System.out.println("============================================");
//System.out.println(timetableTemplateMap);
//System.out.println("============================================");
       Timetable temp = (Timetable)timetableTemplateMap.get(pType);
//System.out.println(temp);
//System.out.println("============================================");
       return (Timetable)cloneObject(temp);
    }

    public Schedule[] getSchedulesTemplate(String pType)
    {
       Schedule[] temp = (Schedule[])scheduleTemplateMap.get(pType);
       return (Schedule[])cloneObject(temp);
    }

    public Schedule getScheduleTemplate(String pType, String name)
    {
//System.out.println("/////////////////////////////////////////////////////////");
//System.out.println(scheduleTemplateMap);
//System.out.println("/////////////////////////////////////////////////////////");
       Schedule[] temp = (Schedule[])scheduleTemplateMap.get(pType);
       for(int i=0; i<temp.length; i++)
       {
          if(name.equals(temp[i].getName()))
             return (Schedule)cloneObject(temp[i]);
       }
       return null;
    }

    public Stage[] getStageTemplates(String pType)
    {
       Stage[] temp = accessStageTemplates(pType);
       return (Stage[])cloneObject(temp);
    }

    public Stage getStageTemplate(String pType, int order)
    {
       Stage[] stages = accessStageTemplates(pType);

       if(order>=0 && order<stages.length)
       {
          return (Stage)cloneObject(stages[order]);
       }
       else
          return null;
    }

    public Stage getStageTemplate(String pType, String sName)
    {
       Stage[] stages = accessStageTemplates(pType);
       for(int i=0 ;i<stages.length; i++)
       {
          if(stages[i].getName().equals(sName))
          {
             Stage temp = (Stage)cloneObject(stages[i]);
             temp.setOrder(i);
             return temp;
          }
       }

       return null;
    }

    public Project getProjectTemplate(String pType)
    {
       Project project = (Project)projectTemplateMap.get(pType);
       if(null!=project)
          return (Project)cloneObject(project);
       else
          return null;
    }

   public String getDefaultProject()
   {
      return defaultProject;
   }

   public String[] getProjectTypes()
   {
      String[] types = new String[projectTemplateMap.size()];
      Iterator it = projectTemplateMap.keySet().iterator();
      int i = 0;
      while(it.hasNext())
      {
         types[i] = (String)it.next();
         i++;
      }
      return types;
   }

   private void loadTemplate(String mapPath, String timetablePath) throws ProjectInitializationException
   {
      projectTemplateMap = new HashMap();
      stageTemplateMap = new HashMap();
      InputStream is = null;
      Node projectNode = null;
      String projectType = null;
      try
      {
         is = Thread.currentThread()
                    .getContextClassLoader()
                    .getResourceAsStream(mapPath);

         if(null==is)
         {
            System.out.println("File " + mapPath + " is not found!");
         }

         ArrayList projects = XmlRWUtil.getNodesFromDocument(XmlRWUtil.read(is), "/projectFactory/project");
         for(int i=0; i<projects.size(); i++)
         {
            // Load project
            projectNode = (Node)projects.get(i);
            Project project = createProjectemplate(projectNode);
            projectType = project.getType();
            projectTemplateMap.put(projectType, project);
//System.out.println("[ProjectFactory::loadTemplate] Load & save project : " + projectType);

            // Load stages for project
            ArrayList stages = XmlRWUtil.getNodesFromDocument(projectNode, "stages/stage");
            Stage[] stageObjs = new Stage[stages.size()];
            for(int j=0; j<stages.size(); j++)
            {
               Stage stageObj = createStageTemplate(projectType, j, (Node)stages.get(j));
               if(null==stageObj)
                  continue;
               stageObjs[j] = stageObj;
            }
            stageTemplateMap.put(projectType, stageObjs);
            ///System.out.println("[ProjectFactory::loadTemplate] Load & save stage : " + projectType);
         }
      }
      catch(Exception e)
      {
         throw new ProjectInitializationException("Load table failis!" + e.toString());
      }

      timetableTemplateMap = new HashMap();
      scheduleTemplateMap = new HashMap();

      ///System.out.println("[ProjectFactory::loadTemplate] Load Timetable template begine ...............................");
      try
      {
         is = Thread.currentThread()
                    .getContextClassLoader()
                    .getResourceAsStream(timetablePath);

         if(null==is)
         {
            System.out.println("File " + timetablePath + " is not found!");
         }

         ArrayList prjtimetables = XmlRWUtil.getNodesFromDocument(XmlRWUtil.read(is), "/project-timetable/project");
         String pjtimetableType = null;

         Node pjtimetableNode = null;
         Node timetablesNode = null;
         Node timetableNode = null;
         Node typeNode = null;
         for(int i=0; i<prjtimetables.size(); i++)
         {
            // Load schedules for project
            pjtimetableNode = (Node)prjtimetables.get(i);
            typeNode = pjtimetableNode.getAttributes().getNamedItem("type");
      	    if(null!=typeNode&&
               null!=pjtimetableNode)
      	    {
               projectType = typeNode.getNodeValue();
               ArrayList timetables = XmlRWUtil.getNodesFromDocument(pjtimetableNode, "timetables");
               for(int j=0; j<timetables.size(); j++)
               {
                  timetablesNode = (Node)timetables.get(j);
                  typeNode = timetablesNode.getAttributes().getNamedItem("type");
                  if(null!=typeNode&&
                     null!=timetablesNode)
                  {
                     String timtablesType = typeNode.getNodeValue();
                     ArrayList timetable = XmlRWUtil.getNodesFromDocument(timetablesNode, "timetable");
                     for(int k=0; k<timetable.size(); k++)
                     {
                        timetableNode = (Node)timetable.get(k);
                        typeNode = timetableNode.getAttributes().getNamedItem("id");
                        if(null!=typeNode&&
                           null!=timetableNode)
                        {
                           String timetableId = typeNode.getNodeValue();
                           Timetable ttable = createTimetableTemplate(projectType+":"+timtablesType+":"+timetableId,
                                                                      timetableNode,
                                                                      (Stage[])stageTemplateMap.get(projectType));
                           if(null!=ttable)
                           {
                              timetableTemplateMap.put(ttable.getProjectType(), ttable);
                              ///System.out.println("[ProjectFactory::loadTemplate] One timetable got built : " + ttable.getProjectType());
                           }
                        }
                     }
                  }
               }
            }
         }
      }
      catch(Exception e)
      {
         throw new ProjectInitializationException("Load table failis!" + e.toString());
      }
      finally
      {
         ///System.out.println("[ProjectFactory::loadTemplate] Load Timetable template end    ...............................");
      }
   }

   private Project createProjectemplate(Node projectNode)
   {
      try
      {
            NamedNodeMap atts = projectNode.getAttributes();

      	    if(null==atts)
      	    {
               return null;
      	    }

            Node typeNode = atts.getNamedItem("type");
            Node displayTypeNameNode = atts.getNamedItem("displayTypeName");

      	    if(null==typeNode||null==displayTypeNameNode)
      	    {
               return null;
      	    }

            String projectType = typeNode.getNodeValue();
            String projectDisplayTypeName = displayTypeNameNode.getNodeValue();

            System.out.println("Project type : " + projectType);

            Node defaultNode = atts.getNamedItem("isDefault");

      	    if(null!=defaultNode&&"yes".equals(defaultNode.getNodeValue()))
      	    {
      	       defaultProject = projectType;
      	    }

            // load data for project
            ArrayList dataGroups = XmlRWUtil.getNodesFromDocument(projectNode, "dataGroup");
            System.out.println("project data group size->" + dataGroups.size());
            String templateId = projectType + ":*";
            Project project = null;
            if(null!=dataGroups)
               project = new Project(projectType, createProjectDatas(templateId, dataGroups));
            else
               project = new Project(projectType, new DataGroup[0]);
            project.setTemplateId(templateId);
            project.setDisplayTypeName(projectDisplayTypeName);
            return project;
      }
      catch(Exception e)
      {
         e.printStackTrace();
         return null;
      }
   }

   private Stage createStageTemplate(String projectType, int order, Node stageNode)
   {
      try
      {
         ArrayList stageDatas = XmlRWUtil.getNodesFromDocument(stageNode, "dataGroup");
         if(null==stageDatas)
            return null;
         // create stage object
         String templateId = projectType + ":" + order;
         Stage stageObj = new Stage(createProjectDatas(templateId, stageDatas));
         stageObj.setOrder(order);
         stageObj.setProjectType(projectType);
         stageObj.setTemplateId(templateId);

         NamedNodeMap stageAtts = stageNode.getAttributes();
         // stage name
         Node stageNameNode = stageAtts.getNamedItem("name");
         if(null!=stageNameNode)
            stageObj.setName(stageNameNode.getNodeValue());


         // date display bgn color
         Node bgnColorOnMasterTableNode = stageAtts.getNamedItem("bgnColorOnMasterTable");
         if(null!=bgnColorOnMasterTableNode)
            stageObj.setBgnColorOnMasterTable(bgnColorOnMasterTableNode.getNodeValue());
         // date on master table
         Node dateOnMasterTableNode = stageAtts.getNamedItem("dateOnMasterTable");
         if(null!=dateOnMasterTableNode&&"yes".equals(dateOnMasterTableNode.getNodeValue()))
            stageObj.setDateOnMasterTable(true);
         // date display name
         Node dateDisplayNameNode = stageAtts.getNamedItem("dateDisplayName");
         if(null!=dateDisplayNameNode)
            stageObj.setDateDisplayName(dateDisplayNameNode.getNodeValue());
         // date display format
         Node dateDisplayFormatNode = stageAtts.getNamedItem("dateDisplayFormat");
         if(null!=dateDisplayFormatNode)
            stageObj.setDateDisplayFormat(dateDisplayFormatNode.getNodeValue());


         // stage ownertype
         Node stageOwnerTypeNode = stageAtts.getNamedItem("ownerType");
         if(null!=stageOwnerTypeNode)
         {
            System.out.println("stage name:" + stageNameNode.getNodeValue() + ", owner type:" +stageOwnerTypeNode.getNodeValue());
            stageObj.setOwnerType(stageOwnerTypeNode.getNodeValue());
         }
         return stageObj;
      }
      catch(Exception e)
      {
         e.printStackTrace();
         return null;
      }
   }

   private Timetable createTimetableTemplate(String projectType,
                                             Node timetableNode,
                                             Stage[] stages)
   {
      try
      {
         Node timelineNode = timetableNode.getAttributes().getNamedItem("timeline");
         String[] days = SMUtility.splitByToken(timelineNode.getNodeValue(), "|", true);

         Timetable timetable = new Timetable(new DataGroup[]{});
         timetable.setId("Timetable template:" + projectType);
         timetable.setProjectType(projectType);

         int day = 0;
         ArrayList schedules = new ArrayList();
         for(int i=0; i<stages.length; i++)
         {
            try
            {
               day = Integer.parseInt(days[i]);
            }
            catch(Exception e)
            {
               continue;
            }

            Schedule schedule = new Schedule(new DataGroup[]{});
            schedule.setProjectType(projectType);
            schedule.setName(stages[i].getName());
            schedule.setDisplayName(stages[i].getDateDisplayName());
            schedule.setDay(day);
            //System.out.println("   Found a schedule : name = " + schedule.getName() + ", display = " + schedule.getDisplayName() + ", day = " + //schedule.getDay());
            schedules.add(schedule);
         }
         scheduleTemplateMap.put(projectType, schedules.toArray(new Schedule[]{}));

         return timetable;
      }
      catch(Exception e)
      {
         e.printStackTrace();
         return null;
      }
   }

   private Timetable createTimetableTemplatex(String projectType, Node timetableNode)
   {
      try
      {
         ArrayList datas = XmlRWUtil.getNodesFromDocument(timetableNode, "dataGroup");
         if(null==datas)
         {
            datas = new ArrayList();
         }
         Timetable timetable = new Timetable(createProjectDatas(projectType, datas));
         timetable.setId("Timetable template:" + projectType);
         timetable.setProjectType(projectType);
         Node scheduleNode = null;
         Schedule schedule = null;
         ArrayList schedules = new ArrayList();
         ArrayList scheduleNodes = XmlRWUtil.getNodesFromDocument(timetableNode, "schedule");
         for(int i=0; i<scheduleNodes.size(); i++)
         {
            scheduleNode = (Node)scheduleNodes.get(i);
            datas = XmlRWUtil.getNodesFromDocument(scheduleNode, "dataGroup");
            if(null==datas)
            {
               datas = new ArrayList();
            }
            schedule = new Schedule(createProjectDatas(projectType, datas));
            schedule.setProjectType(projectType);
            NamedNodeMap scheduleAtts = scheduleNode.getAttributes();
            // schedule name
            Node name = scheduleAtts.getNamedItem("name");
            if(null!=name)
               schedule.setName(name.getNodeValue());
            // schedule name
            Node displayName = scheduleAtts.getNamedItem("displayName");
            if(null!=displayName)
               schedule.setDisplayName(displayName.getNodeValue());
            // date display name
            Node day = scheduleAtts.getNamedItem("day");
            if(null!=day)
            {
               try
               {
                  schedule.setDay(Integer.parseInt(day.getNodeValue()));
               }
               catch(Exception e)
               {
                  System.out.println("[ProjectFactory::createTimetableTemplate] Unable to parse day.");
               }
            }
            //System.out.println("   Found a schedule : name = " + schedule.getName() + ", display = " + schedule.getDisplayName() + ", day = " + //schedule.getDay());
            schedules.add(schedule);
         }
         scheduleTemplateMap.put(projectType, schedules.toArray(new Schedule[]{}));

         return timetable;
      }
      catch(Exception e)
      {
         e.printStackTrace();
         return null;
      }
   }

   private DataGroup[] createProjectDatas(String paraneTemplateId, ArrayList dataGroupNodes) throws Exception
   {
      int size = dataGroupNodes.size();
      if(null==dataGroupNodes||0==size)
         return new DataGroup[0];

      String templateId = null;
      DataGroup[] dataGroups = new DataGroup[size];
      Node dataGroupNode        = null;
      NamedNodeMap dataAtts     = null;
      Node dataNameNode         = null;
      Node dataDisplayNameNode  = null;
      Node dataDisplayOrderNode = null;
      for(int i=0; i<size; i++)
      {
         dataGroupNode = (Node)dataGroupNodes.get(i);
         dataAtts = dataGroupNode.getAttributes();
         dataNameNode = dataAtts.getNamedItem("name");
         dataDisplayNameNode = dataAtts.getNamedItem("displayName");
         dataDisplayOrderNode = dataAtts.getNamedItem("displayOrder");

         templateId = paraneTemplateId + ":" + i;
         dataGroups[i] = createDataTable(templateId, XmlRWUtil.getNodesFromDocument(dataGroupNode, "data"));
         if(null!=dataNameNode)
            dataGroups[i].setName(dataNameNode.getNodeValue());
         if(null!=dataDisplayNameNode)
            dataGroups[i].setDisplayName(dataDisplayNameNode.getNodeValue());
         if(null!=dataDisplayOrderNode)
         {
            try
            {
               dataGroups[i].setDisplayOrder(Integer.parseInt(dataDisplayOrderNode.getNodeValue()));
            }catch(Exception e) {}
         }
      }

      return dataGroups;
   }

   private DataGroup createDataTable(String paraneTemplateId, ArrayList dataNodes) throws Exception
   {
      DataGroup dataTable = new DataGroup();
      Data data = null;

      Node dataNode         = null;
      NamedNodeMap dataAtts = null;
      Node dataTypeNode     = null;
      Node possibleValueNode = null;
      Node dataNameNode     = null;
      Node dataDisplayNameNode  = null;
      Node briefDisplayNameNode = null;
      Node unitNode = null;
      Node isMultiInstanceNode = null;
      Node processorNameNode = null;
      Node cprocessorNameNode = null;
      Node displayerNameNode = null;
      Node onTableNameNode = null;
      Node onMasterTableNode = null;
      Node widthNode = null;
      Node isSortableNode    = null;
      Node onDataSheetNode = null;
      Node isRequiredNode = null;
      Node availForClientNode = null;
      Node dataDisplayOrderNode = null;
      Node subdatasNode = null;
      for(int i=0; i<dataNodes.size(); i++)
      {
         // extract data
         dataNode = (Node)dataNodes.get(i);
         dataAtts = dataNode.getAttributes();
         dataTypeNode = dataAtts.getNamedItem("type");
         possibleValueNode = dataAtts.getNamedItem("possibleValue");
         dataNameNode = dataAtts.getNamedItem("name");
         dataDisplayNameNode = dataAtts.getNamedItem("displayName");
         briefDisplayNameNode = dataAtts.getNamedItem("briefDisplayName");
         unitNode = dataAtts.getNamedItem("unit");
         availForClientNode = dataAtts.getNamedItem("availForClient");
         isMultiInstanceNode = dataAtts.getNamedItem("isMultiInstance");
         processorNameNode = dataAtts.getNamedItem("processorName");
         cprocessorNameNode = dataAtts.getNamedItem("cprocessorName");
         displayerNameNode = dataAtts.getNamedItem("displayerName");
         widthNode = dataAtts.getNamedItem("width");
         onTableNameNode = dataAtts.getNamedItem("onTableName");
         onMasterTableNode = dataAtts.getNamedItem("onMasterTable");
         isSortableNode = dataAtts.getNamedItem("isSortable");
         onDataSheetNode = dataAtts.getNamedItem("onDataSheet");
         isRequiredNode = dataAtts.getNamedItem("isRequired");
         dataDisplayOrderNode = dataAtts.getNamedItem("displayOrder");
         subdatasNode = dataAtts.getNamedItem("subdatas");
         // create data object
         data = new Data();
         if(null!=dataTypeNode)
            data.setType(dataTypeNode.getNodeValue());
         if(null!=possibleValueNode)
            data.setPossibleValue(SMUtility.splitByToken(possibleValueNode.getNodeValue(),"|",false));
         if(null!=dataNameNode)
            data.setName(dataNameNode.getNodeValue());
         if(null!=dataDisplayNameNode)
            data.setDisplayName(dataDisplayNameNode.getNodeValue());
         if(null!=briefDisplayNameNode)
            data.setBriefDisplayName(briefDisplayNameNode.getNodeValue());
         if(null!=unitNode)
            data.setUnit(unitNode.getNodeValue());
         if(null!=availForClientNode&&"yes".equals(availForClientNode.getNodeValue()))
            data.setAvailForClient(true);
         if(null!=isMultiInstanceNode&&"yes".equals(isMultiInstanceNode.getNodeValue()))
            data.setIsMultiInstance(true);
         if(null!=processorNameNode)
            data.setProcessorName(processorNameNode.getNodeValue());
         if(null!=cprocessorNameNode)
            data.setCprocessorName(cprocessorNameNode.getNodeValue());
         if(null!=displayerNameNode)
            data.setDisplayerName(displayerNameNode.getNodeValue());
         if(null!=widthNode)
            data.setWidth(widthNode.getNodeValue());
         if(null!=onTableNameNode)
             data.setOnTableName(onTableNameNode.getNodeValue());
			 
			 
         if(null!=onMasterTableNode&&"yes".equals(onMasterTableNode.getNodeValue())) {
			//System.out.println("paraneTemplateId : " + paraneTemplateId + ", onMasterTable : yes");
            data.setOnMasterTable(true);
		}
         if(null!=isSortableNode&&"yes".equals(isSortableNode.getNodeValue()))
            data.setIsSortable(true);
         if(null!=onDataSheetNode&&"no".equals(onDataSheetNode.getNodeValue()))
            data.setOnDataSheet(false);
         if(null!=isRequiredNode&&"yes".equals(isRequiredNode.getNodeValue()))
            data.setIsRequired(true);
         if(null!=dataDisplayOrderNode)
         {
            try
            {
               data.setDisplayOrder(Integer.parseInt(dataDisplayOrderNode.getNodeValue()));
            }catch(Exception e) {}
         }

         if(null!=subdatasNode)
         {
            try
            {
               data.setSubdatas(SMUtility.splitByToken(subdatasNode.getNodeValue(),"|", true));
            }catch(Exception e) {}
         }

         data.setTemplateId(paraneTemplateId + ":" + data.getName());
//System.out.println("Name:" + data.getName() + ", briefDisplayNameNode:" + data.getIsRequired());

         dataTable.setData(dataNameNode.getNodeValue(), data);
      }

      return dataTable;
   }

     private static Serializable cloneObject(Serializable obj)
    {
       try
       {
          return (Serializable)SerializationUtils.clone(obj);
       }
       catch(Exception e)
       {
          e.printStackTrace();
       }
       return null;
    }

    private static Stage[] accessStageTemplates(String pType)
    {
       return (Stage[])stageTemplateMap.get(pType);
    }

    public static void main(String[] argc)
    {
       try
       {
          ProjectFactory factory = ProjectFactory.getFactory();
          Stage[] stages = factory.getStageTemplates("GT");
          System.out.println("stages size ->" + stages.length);
          for(int i=0; i<stages.length; i++)
          {
             System.out.println("Found a stage : " + stages[i].getName());
             Data[] datas = stages[i].getDatas();
             for(int j=0; j<datas.length; j++)
             {
                if(null!=datas[j])
                   System.out.println("   Found a data : name = " + datas[j].getName() + ", type = " + datas[j].getType());
                else
                   System.out.println("   Found a null data.");
             }
          }
       }
       catch(Exception e)
       {
          e.printStackTrace();
       }
    }
}
