/* Generated by Together */

package org.yang.services.dataAccess.genericDAO;
import java.util.Iterator;
import java.util.HashMap;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.yang.services.dataAccess.DataGroup;
import org.yang.services.dataAccess.DataUnavailableException;
import org.yang.services.dataAccess.Data;

public abstract class StorableDataContainer extends GenericStorableObject
{
    protected HashMap dataGroups = null;

    // Virture function
    public String getId() { return null; }
    public void setId(String id) {}

    public StorableDataContainer()
    {
       dataGroups = new HashMap();
    }

    public StorableDataContainer(DataGroup[] datas) throws DataUnavailableException
    {
       if(null==datas)
          throw new DataUnavailableException("Datas doesn't get initialized.");
       this.dataGroups = new HashMap();
       for(int i=0; i<datas.length; i++)
       {
          dataGroups.put(datas[i].getName(), datas[i]);
       }
    }

    public void putData(String name, Data data) {}

    public Data getData(String name) throws DataUnavailableException
    {
       if(null==dataGroups)
          throw new DataUnavailableException("");
       Iterator it = dataGroups.values().iterator();
       Data temp = null;
       while(it.hasNext())
       {
          temp = ((DataGroup)it.next()).getData(name);
          if(null!=temp)
             return temp;
       }

       throw new DataUnavailableException("No data with the name : " + name);
    }

    public Set getAllOwnerNames()
    {
       HashSet set = new HashSet();
       Iterator it = dataGroups.values().iterator();
       while(it.hasNext())
       {
          set.addAll(((DataGroup)it.next()).getAllOwnerNames());
       }
       return set;
    }

    public String getDataType(String name) throws DataUnavailableException
    {
       return getData(name).getType();
    }

    public String getDataValue(String ownername, String name) throws DataUnavailableException
    {
       return getData(name).getValue(ownername);
    }

    public String getDataValue(String name) throws DataUnavailableException
    {
       return getData(name).getValue();
    }

    public Data[] getDatas() throws DataUnavailableException
    {
       DataGroup[] groupArr = getGroups();
       Data[] dataArr = null;
       ArrayList datas = new ArrayList();
       for(int i=0; i<groupArr.length; i++)
       {
          dataArr = groupArr[i].getDatas();
          for(int j=0; j<dataArr.length; j++)
          {
             datas.add(dataArr[j]);
          }
       }
       return (Data[])datas.toArray(new Data[]{});
    }

    public DataGroup[] getGroups()
    {
       ArrayList groups = new ArrayList();
       Iterator it = dataGroups.values().iterator();
       while(it.hasNext())
       {
          groups.add(it.next());
       }
       Collections.sort(groups);
       return (DataGroup[])groups.toArray(new DataGroup[]{});
    }

    public Data[] getDatas(String dataGroupName)
    {
       DataGroup group = (DataGroup)dataGroups.get(dataGroupName);
       if(null==group)
       {
          return new Data[0];
       }
       return group.getDatas();
    }

    public HashMap getDatasMap() throws DataUnavailableException
    {
       return getDatasMap(Data.ANONYMOUS);
    }

    public HashMap getDatasMap(String ownername) throws DataUnavailableException
    {
       Iterator it = dataGroups.values().iterator();
       HashMap temp = new HashMap();
       while(it.hasNext())
       {
          temp.putAll(((DataGroup)it.next()).getDatasMap(ownername));
       }

       return temp;
    }

    public void setDatasMap(HashMap datasMap) throws DataUnavailableException
    {
       setDatasMap(Data.ANONYMOUS, datasMap);
    }

    public void setDatasMap(String owner, HashMap datasMap) throws DataUnavailableException
    {
       if(null==datasMap)
          throw new DataUnavailableException("Input data map can not be null.");

       Iterator it = dataGroups.values().iterator();
       while(it.hasNext())
       {
          ((DataGroup)it.next()).setDatasMap(owner, datasMap);
       }
    }

    public void rebuildDatas(Data[] datas)
    {
       try
       {
          if(null==datas)
          {
            System.out.println("No data need to be rebuild.");
            return;
          }

          HashMap temp = getDataGroupTemplate();
          if(null==temp)
          {
            System.out.println("DataTable template object can not be null.");
            return;
          }

          Iterator it = temp.values().iterator();
          while(it.hasNext())
          {
             ((DataGroup)it.next()).loadFromDataArray(datas);
          }
          dataGroups = temp;
       }
       catch(Exception e)
       {
          e.printStackTrace();
       }
    }

    public boolean isDataQualified()
    {
       Data[] datas = null;
       try
       {
          datas = getDatas();
       }
       catch(Exception e)
       {
          datas = new Data[0];
       }

       for(int i=0; i<datas.length; i++)
       {
          if(!datas[i].isDataQualified())
          {
             System.out.println("data is not qualified ->" + datas[i].getName());
             return false;
          }
       }

       return true;
    }

    protected abstract HashMap getDataGroupTemplate();
}